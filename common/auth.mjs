const kh_global=Function("return globalThis;")()||Function("return this;")()||Function("return self;")();const as_module=undefined==this;const asWorker="undefined"===typeof window&&"undefined"===typeof process&&self;const cf="kh_server";const mf="common_auth_esm";kh_global.kh??={};kh_global.kh.context??="undefined"!==typeof window?kh_global.parent==kh_global?"window":"iframe":"undefined"!==typeof process?"node.js":"undefined"!==typeof self?self.name??"worker":"unknown";kh_global.kh.storage??={};const cs=kh_global.kh.storage[cf]??={cf,ms:new Set};const ms=kh_global.kh.storage[mf]??={mf,cs};cs.ms.add(ms);import*as kh_js_e from"/contrib/jsm/kh_earlybird.js";import*as kh_js_c from"/contrib/jsm/kh_classes.js";import*as kh_js_f from"/contrib/jsm/kh_functions.js";const kh_js=Object.assign({...kh_js_e},{...kh_js_c},{...kh_js_f});let print_level=undefined;import{Logger}from"/contrib/jsm/kh_log.js";const kh_log=new Logger(print_level,(()=>name));import*as crypto from"crypto";import*as bcrypt from"bcrypt";import{IncomingMessage}from"http";import{getOwnURL}from"/common/utils.mjs";const name=MF`${mf}`;export function bcrypt_hash(text){return bcrypt.hash(text,10)}export async function bcrypt_verify(text,hash){async function cmp(text2cmp,result){return bcrypt.compare(text,text2cmp).then((same=>same?Promise.resolve(result??same):Promise.reject(new kh_js.Error("param-not-match"))))}if("function"==typeof hash){return hash((function verifyer(stored_passw,bcrypt_verify_result){return cmp(stored_passw,bcrypt_verify_result)}))}else return cmp(hash)}const run_password_generator=false;if(run_password_generator){kh_global.kh_auth_run_once=kh_global.kh_auth_run_once??false;(function(passw){if(true==kh_global.kh_auth_run_once)return;if(kh_js.isValid(kh_log))kh_global.kh_auth_run_once=true;if(!Array.isArray(passw))passw=[passw];Promise.all(passw.map(bcrypt_hash)).then((values=>values.map(((value,idx)=>bcrypt_verify(passw[idx],value).then((result=>Promise.resolve({result,value}))).catch((error=>Promise.resolve({result:error,value}))))))).then((result_promises=>Promise.all(result_promises))).then((results=>{results.forEach(((result,idx)=>{kh_log&&kh_log.debug?.(T9`Password Hash for ${passw[idx]} => ${result.value} => verified /${result.result}/`)}))}))})(["xxx","daniel"]);(function(){bcrypt_verify("fabian","$2b$10$DWjaOqrQORhiYGxJeOk1.ecTKn3g8y1RX.ny/yg7OpwP4UEY9pPim").then((res=>kh_log.debug?.("************** successfull verified ***************",res))).catch((err=>kh_log.debug?.("************** failed verified ***************",err)))})()}const static_salt=crypto.randomBytes(16);async function get_key(key_or_req,get_private_key){try{const serverOptions=cs.server_options;let alg="HS512";return new Promise(((resolve,reject)=>{if(kh_js.isString(key_or_req)){crypto.pbkdf2(key_or_req,static_salt,1e5,64,"sha512",((err,derivedKey)=>{if(err)return reject(err);return resolve(derivedKey)}))}else if(key_or_req instanceof IncomingMessage){alg="RS256";return resolve(get_private_key?crypto.createPrivateKey({key:serverOptions.key,passphrase:serverOptions.passphrase,format:"pem",type:"pkcs8",encoding:"utf8"}):crypto.createPublicKey(serverOptions.cert))}else if(key_or_req instanceof crypto.KeyObject)return resolve(key_or_req);else reject(new kh_js.Error("invalid-argument","key"))})).then((key=>({key,alg})))}catch(error){kh_log.info?.(T9`#get_key fails ${error}`);throw error}}import{jwtVerify,SignJWT}from"jose";export async function jwt_sign(key_or_req,payload,{expiration="2h",own_url,alg}={}){try{const{key:privateKeyObject,alg:_alg}=await get_key(key_or_req,true);alg??=_alg;const signed=await new SignJWT(payload).setProtectedHeader({alg}).setIssuedAt().setIssuer(own_url??getOwnURL(key_or_req)).setAudience(own_url??getOwnURL(key_or_req)).setExpirationTime(expiration).sign(privateKeyObject);kh_log.info?.(T9`sign payload result ${signed}`);return signed}catch(error){kh_log.info?.(T9`sign payload fails ${error}`);throw error}}export async function jwt_verify(key_or_req,jwt_token,payload_tests){const{key:publicKeyObject,alg}=await get_key(key_or_req,false);return jwtVerify(jwt_token,publicKeyObject).then((async auth=>{if(!kh_js.isEmpty(payload_tests)){kh_js.for_in(payload_tests,((key,value)=>{const payload_val=auth.payload[key];const cmp=value.cmp||function(plv){return plc==value};if(!cmp(payload_val))throw new kh_js.Error(value.err??"authorization-fails")}))}return auth}))}export async function verify_and_sign(key_or_req,user_or_email,passw,get_password,get_user_token,{expiration,own_url,alg}={}){if("function"!==typeof get_password)return Promise.reject(new kh_js.Error("invalid-argument","get_password function"));return get_password(user_or_email,(function(stored_password,user){return bcrypt_verify(passw,stored_password).then((()=>Promise.resolve(user)))})).then((async user=>{try{let user_token=get_user_token(user);if(user_token instanceof Promise)user_token=await user_token;user_token.id=user_token.id??user.id;return{token:await jwt_sign(key_or_req,user_token,{expiration,own_url,alg}),user}}catch(error){throw error}})).catch((error=>{kh_log.error?.(T9`verification fails => ${error}`);return Promise.reject(new kh_js.Error({error,msg:"authorization-fails"}))}))}kh_global.LoadedScripts.get(mf).resolve(ms);