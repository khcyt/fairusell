const kh_global=Function("return globalThis;")()||Function("return this;")()||Function("return self;")();const as_module=undefined==this;const asWorker="undefined"===typeof window&&"undefined"===typeof process&&self;const cf="kh_db";const mf="kh_db_esm";kh_global.kh??={};kh_global.kh.context??="undefined"!==typeof window?kh_global.parent==kh_global?"window":"iframe":"undefined"!==typeof process?"node.js":"undefined"!==typeof self?self.name??"worker":"unknown";kh_global.kh.storage??={};const cs=kh_global.kh.storage[cf]??={cf,ms:new Set};const ms=kh_global.kh.storage[mf]??={mf,cs};cs.ms.add(ms);let jsm_prefix;if("undefined"!==typeof process){jsm_prefix=`file:///${kh_global.kh.pathes.get("own-module")}`}else{jsm_prefix=nodeFN2ZK(`/contrib/jsm`)}const kh_js={...await import(`${jsm_prefix}/kh_earlybird${VERSION}.js`)};Object.assign(kh_js,await import(`${jsm_prefix}/kh_functions${VERSION}.js`));Object.assign(kh_js,await import(`${jsm_prefix}/kh_classes${VERSION}.js`));const print_level=undefined;const{Logger}=await import(`${jsm_prefix}/kh_log${VERSION}.js`);const kh_log=new Logger(print_level,(()=>MF`${mf}`));if("undefined"!==process){var mergePatch=(await import(`file:///${kh_global.kh.pathes.get("node-module")}/json8-merge-patch/index.js`)).default}else{var mergePatch=kh_js.JSON8MergePatch}let DBStringMap=function(){const db_sm=new kh_js.StringMap({});kh_js.StringMap.getGlobalMap().addEntries(db_sm);return db_sm}();export class BaseExpr{static MakeExpr(base_expr,config){return new class Expr extends base_expr{constructor(config){super(config)}}(config)}static $and(base_expr){return BaseExpr.MakeExpr(base_expr,{keyword:"and",binary:true,operand_arr:true})}static $nand(base_expr){return BaseExpr.MakeExpr(base_expr,{keyword:"and",binary:true,operand_arr:true,negation:true})}static $or(base_expr){return BaseExpr.MakeExpr(base_expr,{keyword:"or",binary:true,operand_arr:true})}static $nor(base_expr){return BaseExpr.MakeExpr(base_expr,{keyword:"or",binary:true,operand_arr:true,negation:true})}}export class SQLExpr{constructor({keyword,operand_arr=false,where_op_writer,binary=false,negation=false,selector=false}={}){this.keyword_=keyword;if(kh_js.isEmpty(keyword))throw new kh_js.Error("non empty keyword expected");this.operand_arr_=operand_arr;this.where_op_writer_="function"!==typeof where_op_writer?SQLExpr.std_where_op_writer.bind(this):where_op_writer.bind(this);this.binary_=binary;this.negation_=negation;this.selector_=selector;kh_js.for_in(arguments[0],((k,v)=>{if(!this.hasOwnProperty(k)&&!this.hasOwnProperty(k+"_"))this[k+"_"]=v}))}where(val,dms=undefined){if(kh_js.isString(val)&&this.operand_arr_){val=JSON.parse(val);if(!Array.isArray(val))throw T9`expected array, got ${val}`}return this.where_op_writer_(val,dms)}isBinary(){return this.binary_}static std_where_op_writer(val,dms=undefined){if(!(this instanceof SQLExpr))throw new kh_js.Error("wrong-usage-of",kh_js.currentFunctionName());if(this.isBinary()){if(!Array.isArray(val))throw T9`expected array, got ${typeof val}`;const ret=val.map((a=>T9`(${SQLExpr.parse(a,undefined,dms)})`)).join(` ${this.keyword_} `);return this.negation_?T9`not (${ret})`:ret}else{const ret=T9`${this.keyword_} (${Array.isArray(val)?val.map((v=>SQLExpr.parse(v,undefined,dms))).join(","):SQLExpr.parse(val,undefined,dms)})`;return this.negation_?T9`not ${ret}`:ret}}static parse(statement,from_clause,dms=undefined){if(kh_js.isEmpty(statement)&&!kh_js.isValid(from_clause))return Array.isArray(statement)?"[]":"";if(kh_js.isString(statement)){try{statement=JSON.parse(statement)}catch(e){return statement}}if("boolean"==typeof statement)return statement;if(kh_js.isString(statement))return`"${statement}"`;if(kh_js.isNumber(statement))return statement;if(Array.isArray(statement))return dms.cvtForQuery(statement)??`'{ ${statement.map((s=>SQLExpr.parse(s,undefined,dms)))} }'`;let where_clause="";let select_list=[];const parsed_from_clause=undefined==from_clause?undefined:SQLExpr.parse(from_clause,undefined,dms);if(parsed_from_clause==from_clause){if(-1==parsed_from_clause?.indexOf("."))from_clause=dms?.tn(from_clause)||from_clause}else from_clause=parsed_from_clause;kh_js.for_in(statement,((k,v)=>{const token=SQLExpr.tokens[k]instanceof SQLExpr?SQLExpr.tokens[k]:undefined;if(!kh_js.isValid(token)){if(!kh_js.isEmpty(where_clause))where_clause+=" and ";const parsed_k=SQLExpr.parse(k,undefined,dms);k=k==parsed_k?dms?.cn(k,from_clause)??k:parsed_k;where_clause+=k;where_clause+=!kh_js.isValid(v)||kh_js.isBuiltIn(v)?SQLExpr.tokens["$eq"].where(v,dms):SQLExpr.parse(v,undefined,dms)}else{if(token.selector_){select_list.push(token.where(v,dms))}else{if(token.isBinary())where_clause+=token.where(v,dms);else where_clause+=token.where(v,dms)}}}));if(kh_js.isEmpty(select_list))select_list.push("*");let first="select";if("function"===typeof select_list[0]){first=select_list.shift()()}return undefined==from_clause?where_clause:T9`${first} ${select_list.join(" ")} from ${from_clause}${kh_js.isEmpty(where_clause)?"":` where ${where_clause}`}`}static tokens=Object.freeze({$not:new SQLExpr({keyword:"<>",negation:false}),$in:new SQLExpr({keyword:"in",operand_arr:true}),$nin:new SQLExpr({keyword:"in",operand_arr:true,negation:true}),$and:BaseExpr.$and(SQLExpr),$nand:BaseExpr.$nand(SQLExpr),$or:BaseExpr.$or(SQLExpr),$nor:BaseExpr.$nor(SQLExpr),$bt:new SQLExpr({keyword:"between",binary:true,operand_arr:true,where_op_writer:function(arr,dms){if(2!=arr.length)throw new kh_js.Error("between requires array with length== 2");return T9`${this.keyword_} ${arr.map((a=>SQLExpr.parse(a,undefined,dms))).join(" and ")}`}}),$nbt:new SQLExpr({keyword:"between",binary:true,operand_arr:true,negation:true,where_op_writer:function(arr){return T9`not ${SQLExpr.tokens.$bt.where_op_writer_(arr)}`}}),$lt:new SQLExpr({keyword:"<"}),$lte:new SQLExpr({keyword:"<="}),$gt:new SQLExpr({keyword:">"}),$gte:new SQLExpr({keyword:">="}),$LIKE:new SQLExpr({keyword:"LIKE"}),$SIMILAR:new SQLExpr({keyword:"SIMILAR TO"}),$NLIKE:new SQLExpr({keyword:"LIKE",negation:true}),$NSIMILAR:new SQLExpr({keyword:"SIMILAR TO",negation:true}),$eq:new SQLExpr({keyword:"=",operand_arr:false,where_op_writer:function(arr,dms){if(!kh_js.isValid(arr))return" IS NULL";let parsed_arr=SQLExpr.parse(arr,undefined,dms);return T9`${parsed_arr==arr||kh_js.isBuiltIn(parsed_arr)?this.keyword_:""} ${parsed_arr}`}}),$intersect:new SQLExpr({keyword:"&&",where_op_writer:function(arr,dms){if(!kh_js.isValid(arr))return" IS NULL";let parsed_arr=SQLExpr.parse(arr,undefined,dms);if(!kh_js.isString(parsed_arr))throw new kh_js.Error({msg:["param-not-match","invalid-type","array expected",parsed_arr]});return T9` ${dms.overlap_op()??this.keyword_} ${parsed_arr}`}}),$union:new SQLExpr({keyword:"||",where_op_writer:function(arr,dms){if(!kh_js.isValid(arr))return" IS NULL";let parsed_arr=SQLExpr.parse(arr,undefined,dms);if(!kh_js.isString(parsed_arr))throw new kh_js.Error({msg:["param-not-match","invalid-type","array expected",parsed_arr]});return T9` ${dms.union_op()??this.keyword_} ${parsed_arr}`}}),$lhr:new SQLExpr({keyword:"@>",where_op_writer:function(arr,dms){if(!kh_js.isValid(arr))return" IS NULL";let parsed_arr=SQLExpr.parse(arr,undefined,dms);if(!kh_js.isString(parsed_arr))throw new kh_js.Error({msg:["param-not-match","invalid-type","array expected",parsed_arr]});return T9` ${dms.lhr_op()??this.keyword_} ${parsed_arr}`}}),$rhl:new SQLExpr({keyword:"<@",where_op_writer:function(arr,dms){if(!kh_js.isValid(arr))return" IS NULL";let parsed_arr=SQLExpr.parse(arr,undefined,dms);if(!kh_js.isString(parsed_arr))throw new kh_js.Error({msg:["param-not-match","invalid-type","array expected",parsed_arr]});return T9` ${dms.rhl_op()??this.keyword_} ${parsed_arr}`}}),$orderby:new SQLExpr({keyword:"order by",where_op_writer:function(arr,dms){if(!Array.isArray(arr))arr=[arr];return T9`${this.keyword_} ${arr.map((a=>{if(kh_js.isString(a))return dms?.cn(a)??a;else if(kh_js.isPlainObject(a)){return Object.entries(a).map((e=>`${dms?.cn(e[0])??e[0]} ${0<=e[1]?"ASC":"DESC"}`)).join(", ")}else return""})).join(", ")}`}}),$distinct:new SQLExpr({keyword:"distinct",selector:true,where_op_writer:function(arr,dms){if(!Array.isArray(arr))arr=[arr];return T9`${this.keyword_} ${arr.map((a=>{const parsed_a=SQLExpr.parse(a,undefined,dms);return a==parsed_a?dms?.cn(a)??a:parsed_a})).join(" ")}`}}),$max:new SQLExpr({keyword:"max",selector:true,where_op_writer:function(arr,dms){if(!Array.isArray(arr))arr=[arr];return T9`${this.keyword_}(${arr.map((a=>{const parsed_a=SQLExpr.parse(a,undefined,dms);return a==parsed_a?dms?.cn(a)??a:parsed_a})).join(" ")})`}}),$min:new SQLExpr({keyword:"min",selector:true,where_op_writer:function(arr,dms){if(!Array.isArray(arr))arr=[arr];return T9`${this.keyword_}(${arr.map((a=>{const parsed_a=SQLExpr.parse(a,undefined,dms);return a==parsed_a?dms?.cn(a)??a:parsed_a})).join(" ")})`}}),$count:new SQLExpr({keyword:"count",selector:true,where_op_writer:function(arr,dms){if(!Array.isArray(arr))arr=[arr];return T9`${this.keyword_}(${arr.map((a=>{const parsed_a=SQLExpr.parse(a,undefined,dms);return a==parsed_a?dms?.cn(a)??a:parsed_a})).join(" ")})`}}),$select:new SQLExpr({keyword:"select",selector:true,where_op_writer:function(arr,dms){if(!Array.isArray(arr))arr=[arr];return arr.map((a=>{const parsed_a=SQLExpr.parse(a,undefined,dms);return a==parsed_a?dms?.cn(a)??a:parsed_a})).join(",")}}),$delete:new SQLExpr({keyword:"delete",selector:true,where_op_writer:function(arr,dms){return()=>"delete"}})})}export class DMS{#config_;#connector_=new kh_js.Deferred;#connector_np_;static#kh_db_connections_={};constructor(config){if(kh_js.isString(config)){try{config=JSON.parse(config)}catch(e){config={}}}this.#config_=config;import(`file:///${kh_global.kh.pathes.get("node-module")}/${this.#config_.npm}/index.js`).then((module=>{this.#connector_np_=module.default();this.#connector_.resolve(this.#connector_np_)}))}quotechar(){return this.#config_.quotechar||"`"}quote(s){const qc=this.quotechar();const must_quote=!kh_js.isString(s)||2>(s?.length??0)||qc!=s[0]&&qc!=s[s.length-1];return must_quote?`${qc}${s?.toString()??""}${qc}`:s}quotestringchar(){return this.#config_.quotestringchar||`'`}quotestring(s){const qc=this.quotestringchar();const must_quote=!kh_js.isString(s)||2>(s?.length??0)||qc!=s[0]&&qc!=s[s.length-1];return must_quote?`${qc}${s?.toString()??""}${qc}`:s}cvtForQuery(o){if(Array.isArray(o))o=`{${o.toString()}}`;return this.quotestring(o)}tn(tn,scheme){return`${!kh_js.isEmpty(scheme)?`${scheme}.`:""}${this.quote(tn)}`}cn(cn,tn){return`${!kh_js.isEmpty(tn)&&"*"!==cn?`${tn}.`:""}${"*"!==cn?this.quote(cn):cn}`}source(){return this.#config_.database}dms(){return"unknown"}config(){return this.#config_}overlap_op(){return this.#config_.overlap_operator||`&&`}union_op(){return this.#config_.overlap_operator||`||`}lhr_op(){return this.#config_.lhr_operator||`@>`}rhl_op(){return this.#config_.rhl_operator||`<@`}connection_string(data){const config=this.config();if(!kh_js.isString(data)){const lowestUser=config.users.lowest||"nodeReader";data=mergePatch.apply({user:lowestUser,password:config.users[lowestUser].password,host:config.host,port:config.port,database:config.database},data||{});data=`${config.protocol}://${data.user}:${encodeURIComponent(data.password)}@${data.host}:${data.port}/${data.database}`}else{if(!data.startsWith(config.protocol))throw new kh_js.Error("param-invalid","protocol")}return data}async connector(){return this.#connector_}connector_np(){return this.#connector_np_}async getConnection(connection_opt){const con2DB=(await this.connector())(connection_opt);const proxy_funcs=this.proxyFuncs(con2DB);const proxy_func_names=Object.getOwnPropertyNames(proxy_funcs);return new Proxy(con2DB,{get:function(obj,prop){if(proxy_func_names.includes(prop))return proxy_funcs[prop].bind(proxy_funcs);else if("then"==prop)return undefined;else return con2DB[prop]}})}static get connections(){return DMS.#kh_db_connections_}async connect(connection_opt){const cs=this.connection_string(connection_opt);if(kh_js.isValid(DMS.connections[cs])){return DMS.connections[cs]}else{return DMS.connections[cs]=await this.getConnection(connection_opt)}}correct_upd(user,password,database){const config=this.#config_;const lowestUser=config.users.lowest||"nodeReader";database=database||kh_js.isPlainObject(user)&&password||config.database;password=user?.password||!kh_js.isPlainObject(user)&&password;user=user?.user||!kh_js.isPlainObject(user)&&user;return{user,password,database}}async connectForUser(user,password,database){({user,password,database}=this.correct_upd(user,password,database));const host=this.#config_.host;const port=this.#config_.port;return this.connect({user,password,host,port,database})}async queryOnKeyStatement(table,allow_unique=true){if(kh_js.isEmpty(table))throw new kh_js.Error("param-not-determined","table-name");if(!kh_js.isValid(this.tableInfo?.[table]?.sql_query_stmt)){const key_cols=await this.KeyColumns(table,allow_unique);const q=this.quote.bind(this);this.tableInfo[table].sql_query_stmt=new((await this.connector()).PreparedStatement)({name:`query-on-key-${table}`,text:`SELECT * FROM public.${q(table)} `+`WHERE ${key_cols.map(((kci,kci_index)=>`${q(kci.column_name)}= $${kci_index+1}`)).join(" AND ")}`})}return this.tableInfo[table].sql_query_stmt}async insertStatement(table){if(kh_js.isEmpty(table))throw new kh_js.Error("param-not-determined","table-name");if(!kh_js.isValid(this.tableInfo?.[table]?.sql_insert_stmt)){const cols=await this.Columns(table);const q=this.quote.bind(this);this.tableInfo[table].sql_insert_stmt=new((await this.connector()).PreparedStatement)({name:`insert-row-full-${table}`,text:`INSERT INTO public.${q(table)} (${cols.map((col=>`${q(col.column_name)}`)).join(",")}) `+`VALUES (${[...Array(cols.length)].map(((v,idx)=>`$${idx+1}`)).join(",")});`})}return this.tableInfo[table].sql_insert_stmt}async updateOnKeyStatement(table,allow_unique=true){if(kh_js.isEmpty(table))throw new kh_js.Error("param-not-determined","table-name");if(!kh_js.isValid(this.tableInfo?.[table]?.sql_update_stmt)){const all_cols=await this.Columns(table);const key_cols=await this.KeyColumns(table,allow_unique);const non_key_cols=await this.NonKeyColumns(table,allow_unique);const q=this.quote.bind(this);const eq_ci=function(ci1,ci2){return ci1?.column_name==ci2?.column_name};this.tableInfo[table].sql_update_stmt=new((await this.connector()).PreparedStatement)({name:`update-on-key-${table}`,text:`UPDATE public.${q(table)} SET ${non_key_cols.map((nkci=>`${q(nkci.column_name)}= $${all_cols.findIndex(eq_ci.bind(undefined,nkci))+1}`)).join(",")} `+`WHERE ${key_cols.map(((kci,kci_index)=>`${q(kci.column_name)}= $${all_cols.findIndex(eq_ci.bind(undefined,kci))+1}`)).join(" AND ")}`})}return this.tableInfo[table].sql_update_stmt}async KeyColumns(table,allow_unique=true){const table_name=table.name??table;try{if(kh_js.isEmpty(table_name))throw new kh_js.Error("param-not-determined","table-name",table_name);if(!kh_js.isValid(this.tableInfo?.[table_name]?.keyCols)){let sql=`SELECT c.column_name, c.data_type FROM information_schema.table_constraints tc `+`JOIN information_schema.constraint_column_usage AS ccu USING (constraint_schema, constraint_name) `+`JOIN information_schema.columns AS c ON c.table_schema = tc.constraint_schema `+`AND tc.table_name = c.table_name AND ccu.column_name = c.column_name `+`WHERE constraint_type = 'PRIMARY KEY' and tc.table_name = $1;`;const q=this.quote.bind(this);const highestUser=this.#config_.users.highest??"node";const con=await this.connectForUser(highestUser,this.#config_.users[highestUser].password);let rows=await con.manyOrNone({text:sql,values:[table_name]});if(kh_js.isEmpty(rows)&&allow_unique){sql=`select array_agg(ccu.column_name) as column_names, ccu.constraint_name from information_schema.table_constraints tc\n                                inner join information_schema.constraint_column_usage ccu on tc.constraint_name= ccu.constraint_name\n                          where tc.constraint_type= 'UNIQUE' and tc.table_name= $1\n                          group by ccu.constraint_name`;rows=await con.one({text:sql,values:[table_name]});if(!kh_js.isEmpty(rows.column_names)){sql=`select column_name, data_type from information_schema.columns where table_name= $1 and information_schema.columns.column_name in (select unnest($2::text[]));`;rows=await con.many({text:sql,values:[table_name,rows.column_names]})}}this.tableInfo??={};this.tableInfo[table_name]??={};this.tableInfo[table_name].keyCols=rows||[]}return this.tableInfo[table_name].keyCols}catch(error){kh_log.error?.(T9`error during retrieve KeyColumns for ${table_name}, error => ${error}`);throw error}}async Columns(table){const table_name=table.name??table;try{if(kh_js.isEmpty(table_name))throw new kh_js.Error("param-not-determined","table-name");if(!kh_js.isValid(this.tableInfo?.[table_name]?.Cols)){const sql=`select column_name, data_type from information_schema.columns where table_name= $1;`;const highestUser=this.#config_.users.highest??"node";const con=await this.connectForUser(highestUser,this.#config_.users[highestUser].password);const rows=await con.many({text:sql,values:[table_name]});if(kh_js.isEmpty(rows))throw new kh_js.Error("param-not-determined","column_names",`${this.#config_.database}.${table_name}`);this.tableInfo??={};this.tableInfo[table_name]??={};this.tableInfo[table_name].Cols=rows}return this.tableInfo[table_name].Cols}catch(error){kh_log.error?.(T9`error during retrieve Columns for ${table_name}, error => ${error}`);throw error}}async NonKeyColumns(table,allow_unique=true){const[cols,key_cols]=await Promise.all([this.Columns(table),this.KeyColumns(table,allow_unique)]);return cols.filter((ci=>-1==key_cols.findIndex((kci=>kci.column_name==ci.column_name))))}async tablenames(forUser){try{if(!kh_js.isValid(this.tableInfo?.["public"]?.Names)){const sql=this.tablenames_query();const user=forUser??this.#config_.users.highest??"node";const con=await this.connectForUser(user,this.#config_.users[user].password);const rows=await con.many({text:sql,values:[]});if(kh_js.isEmpty(rows))throw new kh_js.Error("param-not-determined","table_names",`${this.#config_.database}`);this.tableInfo??={};this.tableInfo["public"]??={};this.tableInfo["public"].Names=rows.map((row=>row.table_name))}return this.tableInfo["public"].Names}catch(error){kh_log.error?.(T9`error during retrieve Table Names, error => ${error}`);throw error}}proxyFuncs(connection){const dms_this=this;return new Object({DMS:()=>dms_this,queryAll:async function(tablename,{from,limit=1e3,hints}={}){const sql_query=`select * from ${dms_this.tn(tablename)}`;const sql_hints=SQLExpr.parse(hints,undefined,dms_this);kh_log.debug?.(`SQL QUERY SPECIFICATION: ${sql_query} h(${sql_hints})`);const statement=!kh_js.isValid(from)?`${sql_query} ${sql_hints};`:0<=from?`${sql_query} ${sql_hints} offset ${from} limit ${limit};`:`${sql_query} ${sql_hints} offset greatest(0, (select count(*) from (${sql_query}) as t)- ${-from}) limit ${limit};`;const result={query:"all",statement:`${sql_query} ${sql_hints}`};return connection.query(statement).then((rows=>Promise.resolve({result:rows,...result,all:true}))).catch((error=>Promise.reject({error,...result})))},queryRange:async function(tablename,query,{from,limit=1e3,hints}={}){if(kh_js.isEmpty(query))return this.queryAll(tablename,{from,limit,hints});const sql_query=SQLExpr.parse(query||{},dms_this.tn(tablename),dms_this);const sql_hints=SQLExpr.parse(hints,undefined,dms_this);kh_log.debug?.(`SQL QUERY SPECIFICATION: ${sql_query} h(${sql_hints})`);if(false)return mp$database.query(`select * from (select row_number() over(order by (select 1)) as "RowNum", * from ${tablename}) as tbl where ${from}< "RowNum" and ${from+limit} >"RowNum"`).then((rows=>{rows.forEach((row=>delete row.RowNum));return Promise.resolve(rows)}));const statement=0<=from?`${sql_query} ${sql_hints} offset ${from} limit ${limit};`:`${sql_query} ${sql_hints} offset greatest(0, (select count(*) from (${sql_query}) as t)- ${-from}) limit ${limit};`;const result={query,statement:`${sql_query} ${sql_hints}`};return connection.query(statement).then((rows=>Promise.resolve({result:rows,...result}))).catch((error=>Promise.reject({error,...result})))},delete:async function(tablename,query={}){let sql_query_spec="";if(kh_js.isString(query)){try{if(kh_js.isEmpty(query))query="{}";query=JSON.parse(query)}catch(error){throw error}}const modified_query={$delete:"",...query};sql_query_spec=SQLExpr.parse(modified_query,dms_this.tn(tablename),dms_this);kh_log.debug?.(`SQL QUERY SPECIFICATION: ${sql_query_spec}`);const statement=sql_query_spec;const result={query,statement};return connection.query(statement).then((rows=>Promise.resolve({result:rows,...result}))).catch((error=>Promise.reject({error,...result})))},execStatement:async function(statement,values,from,limit=1e3){const result={query:statement.text||statement,statement:statement.text||statement};return connection.query(statement,values).then((async rows=>({result:rows.slice(from,from+limit),...result,all:0==from&&rows.length==limit?true:0==rows.length?undefined:false}))).catch((async error=>Promise.reject({error,...result})))}})}static create(dms_key,config){return new createClass(dms_key)(config)}static createClass(dms_key){switch(dms_key){case"postgresql":case"postgres":case"pg":case"pg-promise":default:return class extends PGPromise{constructor(config){super(config)}};case"mariadb":case"MariaDB":return class extends MariaDB{constructor(config){super(config)}}}}}export class PGPromise extends DMS{constructor(config){super(kh_js.JSON8MergePatch.apply({npm:"pg-promise/lib",quotechar:'"',quotestringchar:"$$",protocol:"postgres"},config||{}));["PostgreSQL"].forEach((used=>kh_js.Copyright.used.add(used)))}tn(tn,scheme="public"){const _tn=super.connector_np()?.helpers?.TableName;if(tn instanceof _tn)return tn.name;return super.tn(tn,scheme)}dms(){return"postgresql"}tablenames_query(){return`SELECT table_name FROM information_schema.tables WHERE table_type='BASE TABLE' AND table_schema='public'`}}export class MariaDB extends DMS{constructor(config){super(kh_js.JSON8MergePatch.apply({npm:"mariadb",quotechar:"`",protocol:"mariadb"},config||{}));["MariaDB"].forEach((used=>kh_js.Copyright.used.add(used)))}tn(tn,scheme){return super.tn(tn,scheme)}dms(){return"mariadb"}tablenames_query(){return`SELECT table_name FROM information_schema.tables WHERE table_type='BASE TABLE' AND table_schema=$1`}}export class Table{constructor(name){this["#name_"]=name}static async create(name,dms_or_columns,data_set){const t=new Table(name);return t.initColumns(dms_or_columns,data_set).then((async()=>t))}get name(){return this["#name_"]}get columns(){return this["#columns_"]}get values(){const ret={};Object.entries(this.columns)?.forEach((([cn,ci])=>ret[ci.column_name]=ci.value));return ret}async clone(){return Table.create(this.name,this.columns)}async initColumns(dms_or_columns,data_set){try{const table_this=this;await new Promise((function(resolve,reject){if(!kh_js.isValid(table_this["#columns_"])){if(Array.isArray(dms_or_columns)){return resolve(dms_or_columns)}else{(dms_or_columns?.Columns?.(table_this["#name_"])??Promise.resolve(undefined)).then((columns=>resolve(columns||[]))).catch((error=>{kh_log.error?.(T9`(1) error in initColumns => ${error}`);return reject(error)}))}}else resolve([])})).then((columns=>{if(!kh_js.isEmpty(columns)){table_this["#columns_"]=table_this["#columns_"]||{};columns.forEach((column=>table_this["#columns_"][column.column_name]={...table_this["#columns_"][column.column_name]??{},...column}))}return Promise.resolve(true)}));!kh_js.isEmpty(data_set)&&kh_js.for_in(this["#columns_"]??{},((cn,ci)=>{if(ci.column_name in data_set)ci.value=data_set[ci.column_name]?.value??data_set[ci.column_name]}));return true}catch(error){kh_log.error?.(T9`(2) error in initColumns => ${error}`);return Promise.reject(error)}}async queryAll(connection){if(!kh_js.isValid(connection))throw new kh_js.Error("param-not-determined",'"connection"');return connection.queryAll(this.name).then((result=>Promise.resolve(result.result)))}async queryOnKey(data_set,connection,silent=false,allow_unique=true){try{if(!kh_js.isValid(connection))throw new kh_js.Error("param-not-determined",'"connection"');const dms=connection.DMS();if(!kh_js.isValid(dms))throw new kh_js.Error("param-not-determined",'"DMS"');await this.initColumns(dms,data_set);const key_cols=await dms.KeyColumns(this,allow_unique);if(kh_js.isEmpty(key_cols))throw new kh_js.Error("param-not-determined",'"primary indexes"');const stmt=await dms.queryOnKeyStatement(this.name,allow_unique);let table_this=this;return connection.execStatement(stmt,key_cols.map((kci=>this["#columns_"][kci.column_name].value)),0).then((result=>{if(1!=result.result.length)throw new kh_js.Error({msg:"data-not-determined",length:result.result.length});const q_data_set=result.result[0];kh_js.for_in(table_this["#columns_"]??{},((cn,ci)=>{if(ci.column_name in q_data_set)ci.value=q_data_set[ci.column_name]}));return Promise.resolve(table_this)})).catch((error=>{if(true!=silent)kh_log.error?.(T9`error during queryOnKey, error => ${error}, $cn= ${connection.$cn}`);throw error}))}catch(error){kh_log.error?.(T9`error during queryOnKey, error => ${error}, $cn= ${connection.$cn}`);throw error}}async save(new_data_set_value,connection,allow_unique=true){try{if(!kh_js.isValid(new_data_set_value))throw new kh_js.Error("param-not-determined","data-set");if(!kh_js.isValid(connection))throw new kh_js.Error("param-not-determined","connection");const dms=connection.DMS();if(!kh_js.isValid(dms))throw new kh_js.Error("param-not-determined","DMS");await this.initColumns(dms);const key_cols=await dms.KeyColumns(this,allow_unique);let update=0!=key_cols.length;try{if(!update)throw"insert";key_cols.forEach((kci=>this["#columns_"][kci.column_name].value=new_data_set_value[kci.column_name]?.value??new_data_set_value[kci.column_name]));await this.queryOnKey(undefined,connection,true)}catch(error){update=false}await this.initColumns(dms,new_data_set_value);const stmt=await dms[update?"updateOnKeyStatement":"insertStatement"](this.name);let values;values=(await dms.Columns(this)).map((ci=>this["#columns_"][ci.column_name].value));const table_this=this;return connection.execStatement(stmt,values,0).then((result=>{if((update?0:0)!=result.result.length)throw new kh_js.Error({msg:"data-not-determined",length:result.result.length});return Promise.resolve(table_this)})).catch((error=>{kh_log.error?.(T9`error during save(new_data_set), error => ${error}`);throw error}))}catch(error){kh_log.error?.(T9`error during save(new_data_set), error => ${error}`);throw error}}}export class Util{static repl(s){return kh_js.isString(s)?s.replace(/>/g,"&gt;").replace(/</g,"&lt;"):s}static cvt_error(error,status=400,req){if("28000"==error.error?.code||"28P01"==error.error?.code)status=401;return JSON.parse(JSON.stringify({...error,query:Util.repl(error.query||req?.query),statement:Util.repl(error.statement),detail:Util.repl(error.detail||error.error||error.message)||error,status:error.status||status,dberror:error.error?{...error.error}:undefined}).replace(/\\"/g,""))}}export{DBStringMap};kh_global.LoadedScripts.get(mf).resolve(ms);